# =============================================================================
# DEMO STEP 3: ADD PII COLUMN - AUTONOMOUS SECURITY MAGIC
# =============================================================================
# This demonstrates Kolumn's intelligent PII detection and automatic security
# policy application. Watch as a new sensitive column triggers security 
# measures across the entire ecosystem automatically!
# =============================================================================

terraform {
  required_providers {
    postgres = {
      source = "kolumn/postgres"
    }
    kafka = {
      source = "kolumn/kafka"
    }
    dagster = {
      source = "kolumn/dagster"
    }
  }
}

provider "postgres" {
  host     = "localhost"
  port     = 5432
  database = "kolumn_demo"
  username = "postgres"
  password = "postgres"
}

provider "kafka" {
  bootstrap_servers   = ["localhost:9092"]
  schema_registry_url = "http://localhost:8081"
}

provider "dagster" {
  host = "localhost"
  port = 3000
}

# -----------------------------------------------------------------------------
# STEP 3: SOURCE SCHEMA WITH PII COLUMN ADDED
# -----------------------------------------------------------------------------

# Users table now includes phone number (will be detected as PII!)
create "postgres_table" "demo_users" {
  name = "demo_users"

  # All previous columns
  column "id" {
    type        = "BIGSERIAL"
    primary_key = true
  }

  column "email" {
    type     = "VARCHAR(255)"
    unique   = true
    nullable = false
  }

  column "first_name" {
    type     = "VARCHAR(100)"
    nullable = false
  }

  column "middle_name" {
    type     = "VARCHAR(100)"
    nullable = true
  }

  column "last_name" {
    type     = "VARCHAR(100)"
    nullable = false
  }

  # üõ°Ô∏è NEW PII COLUMN: This will trigger automatic security measures!
  column "phone" {
    type     = "VARCHAR(20)"
    nullable = true
  }

  column "created_at" {
    type    = "TIMESTAMP"
    default = "CURRENT_TIMESTAMP"
  }

  # Sample data with phone numbers
  initial_data = [
    {
      email       = "alice@example.com"
      first_name  = "Alice"
      middle_name = "Marie"
      last_name   = "Johnson"
      phone       = "+1-555-0123" # PII data
    },
    {
      email       = "bob@example.com"
      first_name  = "Bob"
      middle_name = "James"
      last_name   = "Smith"
      phone       = "+1-555-0456" # PII data
    },
    {
      email       = "carol@example.com"
      first_name  = "Carol"
      middle_name = null
      last_name   = "Williams"
      phone       = "+1-555-0789" # PII data
    }
  ]
}

# üõ°Ô∏è INTELLIGENT SCHEMA: Now with PII detection!
create "kolumn_data_object" "demo_user_schema" {
  name        = "Demo User Schema"
  description = "EVOLVED schema with PII detection - phone automatically secured!"

  dynamic "column" {
    for_each = {
      id = {
        name        = "id"
        type        = "BIGINT"
        nullable    = false
        primary_key = true
      }
      email = {
        name     = "email"
        type     = "VARCHAR(255)"
        nullable = false
        unique   = true
      }
      first_name = {
        name     = "first_name"
        type     = "VARCHAR(100)"
        nullable = false
      }
      middle_name = {
        name     = "middle_name"
        type     = "VARCHAR(100)"
        nullable = true
      }
      last_name = {
        name     = "last_name"
        type     = "VARCHAR(100)"
        nullable = false
      }
      # üÜï NEW PII COLUMN: Automatically detected as sensitive
      phone = {
        name     = "phone"
        type     = "VARCHAR(20)"
        nullable = true
      }
      created_at = {
        name     = "created_at"
        type     = "TIMESTAMP"
        nullable = true
      }
    }

    content {
      name     = column.value.name
      type     = column.value.type
      nullable = column.value.nullable

      # üõ°Ô∏è AUTONOMOUS PII DETECTION: Based on column name patterns
      classifications = contains(["email", "phone", "ssn"], column.key) ? [
        kolumn_classification.pii
        ] : [
        kolumn_classification.public
      ]
    }
  }

  metadata = {
    source            = "postgres_table.demo_users"
    demo_step         = "add_pii"
    evolution         = "added_phone_column_with_pii_detection"
    security_enhanced = true
    created_at        = timestamp()
  }
}

# Enhanced classification definitions with security policies
create "kolumn_classification" "pii" {
  name        = "PII"
  description = "Personally Identifiable Information - Enhanced Security"
  requirements = {
    encryption       = true
    audit_access     = true
    retention_period = "7_years"
    access_controls  = "restricted"
    data_masking     = true
  }

  # üõ°Ô∏è SECURITY POLICIES: Applied automatically to PII columns
  encryption_config = {
    postgres = {
      method    = "column_encryption"
      algorithm = "AES-256-GCM"
    }
    kafka = {
      method    = "field_level_encryption"
      algorithm = "AES-256-CTR"
    }
  }
}

create "kolumn_classification" "public" {
  name        = "Public"
  description = "Public information - Standard Security"
  requirements = {
    encryption   = false
    audit_access = false
  }
}

# -----------------------------------------------------------------------------
# DERIVED RESOURCES WITH AUTOMATIC SECURITY MEASURES
# -----------------------------------------------------------------------------

# üõ°Ô∏è ANALYTICS TABLE: PII columns automatically encrypted!
create "postgres_table" "demo_user_analytics" {
  name = "demo_user_analytics"

  dynamic "column" {
    for_each = kolumn_data_object.demo_user_schema.columns
    content {
      name     = column.value.name
      type     = column.value.type
      nullable = column.value.nullable

      # üõ°Ô∏è AUTOMATIC ENCRYPTION: Applied to PII columns
      encrypted = contains(column.value.classifications, kolumn_classification.pii)
    }
  }

  # Analytics columns
  column "total_sessions" {
    type    = "INTEGER"
    default = 0
  }

  column "last_activity" {
    type     = "TIMESTAMP"
    nullable = true
  }

  # üõ°Ô∏è PII AUDIT: Automatically track access to sensitive data
  audit_config = {
    track_pii_access = true
    pii_columns = [
      for col in kolumn_data_object.demo_user_schema.columns : col.name
      if contains(col.classifications, kolumn_classification.pii)
    ]
    log_level = "detailed"
  }
}

# üõ°Ô∏è KAFKA TOPIC: PII data automatically handled securely!
create "kafka_topic" "demo_user_events" {
  name               = "demo-user-events"
  partitions         = 3
  replication_factor = 1

  schema_registry_config = {
    # Event metadata
    fields = {
      event_type = {
        type     = "string"
        nullable = false
      }
      event_timestamp = {
        type     = "long"
        nullable = false
      }
    }
  }

  # üìä NON-PII FIELDS: Safe for public events
  dynamic "non_pii_field" {
    for_each = {
      for name, col in kolumn_data_object.demo_user_schema.columns : name => col
      if !contains(col.classifications, kolumn_classification.pii)
    }
    content {
      name     = non_pii_field.value.name
      type     = non_pii_field.value.type == "VARCHAR(255)" ? "string" : non_pii_field.value.type == "VARCHAR(100)" ? "string" : non_pii_field.value.type == "VARCHAR(20)" ? "string" : non_pii_field.value.type == "BIGINT" ? "long" : non_pii_field.value.type == "TIMESTAMP" ? "long" : "string"
      nullable = non_pii_field.value.nullable
    }
  }

  # üõ°Ô∏è PII FIELDS: Only hashed versions for analytics
  dynamic "pii_field" {
    for_each = {
      for name, col in kolumn_data_object.demo_user_schema.columns : "${name}_hash" => col
      if contains(col.classifications, kolumn_classification.pii)
    }
    content {
      name     = pii_field.key # email_hash, phone_hash
      type     = "string"      # Hash is always a string
      nullable = true
      doc      = "SHA256 hash of ${replace(pii_field.key, "_hash", "")} for privacy-safe analytics"
    }
  }

  # üõ°Ô∏è PRIVACY CONFIGURATION: Automatic based on PII detection
  privacy_config = {
    pii_handling          = "hash_only"
    encryption_at_rest    = true
    retention_policy      = "30_days" # Shorter for events with PII
    right_to_be_forgotten = true
  }
}

# üõ°Ô∏è SQL FILE: PII-aware with automatic masking
discover "kolumn_file" "demo_sql_analytics" {
  location = "./files/demo_user_analytics_pii.sql"
  inputs = {
    user_columns = kolumn_data_object.demo_user_schema.columns
    source_table = postgres_table.demo_users.name

    # üõ°Ô∏è PII-AWARE INPUTS: Separate PII and public columns
    pii_columns = [
      for col in kolumn_data_object.demo_user_schema.columns : col.name
      if contains(col.classifications, kolumn_classification.pii)
    ]
    public_columns = [
      for col in kolumn_data_object.demo_user_schema.columns : col.name
      if !contains(col.classifications, kolumn_classification.pii)
    ]
  }
}

# üõ°Ô∏è DAGSTER JOB: PII-aware processing with security measures
create "dagster_job" "demo_user_processor_secure" {
  name        = "demo-user-processor-secure"
  description = "Secure user processing with automatic PII handling!"

  config = {
    source_table = postgres_table.demo_users.name
    target_table = postgres_table.demo_user_analytics.name
    kafka_topic  = kafka_topic.demo_user_events.name

    # üìä PUBLIC PROCESSING: Safe for analytics
    public_columns = [
      for col in kolumn_data_object.demo_user_schema.columns : col.name
      if !contains(col.classifications, kolumn_classification.pii)
    ]

    # üõ°Ô∏è PII PROCESSING: Secure handling required
    pii_columns = [
      for col in kolumn_data_object.demo_user_schema.columns : col.name
      if contains(col.classifications, kolumn_classification.pii)
    ]

    # Security measures automatically applied
    security_config = {
      hash_pii_for_analytics = true
      encrypt_pii_at_rest    = true
      audit_pii_access       = true
      pii_retention_days     = 2555 # 7 years
    }

    # Full name computation (safe - uses only public fields)
    computed_fields = {
      full_name = "CONCAT(first_name, COALESCE(' ' || middle_name, ''), ' ', last_name)"
      # phone_hash computed securely for analytics
      phone_analytics_id = "SHA256(phone)"
    }
  }
}

# üõ°Ô∏è COMPLIANCE MONITORING: Automatic for PII handling
create "kolumn_monitor" "pii_compliance" {
  name        = "PII Compliance Monitor"
  description = "Automatically monitors PII handling across all resources"

  checks = [
    {
      type = "pii_encryption"
      resources = [
        postgres_table.demo_user_analytics.name,
        kafka_topic.demo_user_events.name
      ]
      frequency = "hourly"
      severity  = "critical"
    },
    {
      type            = "pii_access_audit"
      resources       = ["*"]
      frequency       = "real-time"
      alert_threshold = 10 # Alert on unusual access patterns
    },
    {
      type = "data_retention"
      pii_columns = [
        for col in kolumn_data_object.demo_user_schema.columns : col.name
        if contains(col.classifications, kolumn_classification.pii)
      ]
      frequency = "daily"
    }
  ]

  notifications = {
    slack_channel = "#security-alerts"
    email         = ["security-team@company.com", "dpo@company.com"]
  }
}

# =============================================================================
# PII DETECTION AND SECURITY DEMONSTRATION
# =============================================================================

output "demo_step3_summary" {
  value = <<-EOT
    üõ°Ô∏è DEMO STEP 3: AUTONOMOUS PII SECURITY IN ACTION!
    
    What Changed:
    üîÑ Source table: Added 'phone VARCHAR(20)' column
    
    What Kolumn Detected Automatically:
    üîç Column name 'phone' ‚Üí Classified as PII
    üõ°Ô∏è Security policies ‚Üí Applied automatically across all resources
    
    Autonomous Security Measures Applied:
    ‚úÖ Analytics table: phone column encrypted automatically
    ‚úÖ Kafka events: Raw phone excluded, phone_hash included for analytics
    ‚úÖ SQL files: PII-aware processing with masking capabilities
    ‚úÖ Dagster job: Secure PII handling with hashing and audit
    ‚úÖ Compliance monitoring: Automatic PII oversight configured
    
    Zero Security Configuration Required! üéâ
    
    Security Features Activated:
    ‚Ä¢ Column-level encryption in PostgreSQL
    ‚Ä¢ Field-level encryption for Kafka
    ‚Ä¢ Automatic audit logging for PII access
    ‚Ä¢ Hash-only analytics processing
    ‚Ä¢ GDPR compliance features (right to be forgotten)
    ‚Ä¢ Real-time security monitoring
    
    Commands:
    1. kolumn plan -c demo-step3-add-pii.kl
    2. kolumn apply -c demo-step3-add-pii.kl
    
    Next: Run demo-step4-complex-evolution.kl for advanced scenarios! üöÄ
  EOT
}

output "pii_security_analysis" {
  value = {
    detected_pii_columns = ["email", "phone"]
    public_columns       = ["id", "first_name", "middle_name", "last_name", "created_at"]

    security_measures = {
      database_encryption   = "AES-256-GCM column encryption"
      kafka_privacy         = "Hash-only transmission (phone_hash, email_hash)"
      audit_logging         = "Real-time PII access tracking"
      retention_policy      = "7 years for PII, 30 days for events"
      compliance_frameworks = ["GDPR", "CCPA", "HIPAA-ready"]
    }

    automatic_adaptations = [
      "phone column encrypted in all database tables",
      "Kafka schema excludes raw phone, includes phone_hash",
      "SQL processing gets PII-aware variables",
      "Dagster job separates PII and public processing",
      "Compliance monitoring covers all PII columns",
      "Security alerts configured for unusual access"
    ]
  }
}

output "security_magic_proof" {
  value = <<-EOT
    üõ°Ô∏è PROOF OF AUTONOMOUS SECURITY:
    
    PII Detection: phone ‚Üí Automatic classification
    Security Cascade: 6 resources secured automatically
    
    Manual Security Config Required: ZERO ‚ùå
    
    Before: Public column handling
    After: Enterprise-grade PII security
    
    Files That DID NOT CHANGE:
    ‚ùå No manual encryption configuration
    ‚ùå No manual Kafka privacy setup
    ‚ùå No manual audit logging config
    ‚ùå No manual compliance monitoring
    
    Everything Secured Automatically! üîê
    
    This is Security-as-Code perfection with Kolumn!
  EOT
}